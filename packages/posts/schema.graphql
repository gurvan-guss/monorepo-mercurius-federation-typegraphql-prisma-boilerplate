# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

directive @extends on INTERFACE | OBJECT

directive @external on FIELD_DEFINITION | OBJECT

directive @key(fields: String!) on INTERFACE | OBJECT

directive @provides(fields: String!) on FIELD_DEFINITION

directive @requires(fields: String!) on FIELD_DEFINITION

directive @tag(name: String!) repeatable on FIELD_DEFINITION

type AffectedRowsOutput {
  count: Int!
}

type AggregateCategoriesOnPosts {
  _count: CategoriesOnPostsCountAggregate
  _max: CategoriesOnPostsMaxAggregate
  _min: CategoriesOnPostsMinAggregate
}

type AggregateCategory {
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
}

type AggregatePost {
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
}

type CategoriesOnPosts {
  category: Category!
  categoryId: String!
  createdAt: DateTime!
  post: Post!
  postId: String!
  updatedAt: DateTime!
}

type CategoriesOnPostsCountAggregate {
  _all: Int!
  categoryId: Int!
  createdAt: Int!
  postId: Int!
  updatedAt: Int!
}

input CategoriesOnPostsCreateInput {
  category: CategoryCreateNestedOneWithoutPostsInput!
  createdAt: DateTime
  post: PostCreateNestedOneWithoutCategoriesInput!
  updatedAt: DateTime
}

input CategoriesOnPostsCreateManyCategoryInput {
  createdAt: DateTime
  postId: String!
  updatedAt: DateTime
}

input CategoriesOnPostsCreateManyCategoryInputEnvelope {
  data: [CategoriesOnPostsCreateManyCategoryInput!]!
  skipDuplicates: Boolean
}

input CategoriesOnPostsCreateManyInput {
  categoryId: String!
  createdAt: DateTime
  postId: String!
  updatedAt: DateTime
}

input CategoriesOnPostsCreateManyPostInput {
  categoryId: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input CategoriesOnPostsCreateManyPostInputEnvelope {
  data: [CategoriesOnPostsCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input CategoriesOnPostsCreateNestedManyWithoutCategoryInput {
  connect: [CategoriesOnPostsWhereUniqueInput!]
  connectOrCreate: [CategoriesOnPostsCreateOrConnectWithoutCategoryInput!]
  create: [CategoriesOnPostsCreateWithoutCategoryInput!]
  createMany: CategoriesOnPostsCreateManyCategoryInputEnvelope
}

input CategoriesOnPostsCreateNestedManyWithoutPostInput {
  connect: [CategoriesOnPostsWhereUniqueInput!]
  connectOrCreate: [CategoriesOnPostsCreateOrConnectWithoutPostInput!]
  create: [CategoriesOnPostsCreateWithoutPostInput!]
  createMany: CategoriesOnPostsCreateManyPostInputEnvelope
}

input CategoriesOnPostsCreateOrConnectWithoutCategoryInput {
  create: CategoriesOnPostsCreateWithoutCategoryInput!
  where: CategoriesOnPostsWhereUniqueInput!
}

input CategoriesOnPostsCreateOrConnectWithoutPostInput {
  create: CategoriesOnPostsCreateWithoutPostInput!
  where: CategoriesOnPostsWhereUniqueInput!
}

input CategoriesOnPostsCreateWithoutCategoryInput {
  createdAt: DateTime
  post: PostCreateNestedOneWithoutCategoriesInput!
  updatedAt: DateTime
}

input CategoriesOnPostsCreateWithoutPostInput {
  category: CategoryCreateNestedOneWithoutPostsInput!
  createdAt: DateTime
  updatedAt: DateTime
}

type CategoriesOnPostsGroupBy {
  _count: CategoriesOnPostsCountAggregate
  _max: CategoriesOnPostsMaxAggregate
  _min: CategoriesOnPostsMinAggregate
  categoryId: String!
  createdAt: DateTime!
  postId: String!
  updatedAt: DateTime!
}

input CategoriesOnPostsListRelationFilter {
  every: CategoriesOnPostsWhereInput
  none: CategoriesOnPostsWhereInput
  some: CategoriesOnPostsWhereInput
}

type CategoriesOnPostsMaxAggregate {
  categoryId: String
  createdAt: DateTime
  postId: String
  updatedAt: DateTime
}

type CategoriesOnPostsMinAggregate {
  categoryId: String
  createdAt: DateTime
  postId: String
  updatedAt: DateTime
}

input CategoriesOnPostsOrderByInput {
  categoryId: SortOrder
  createdAt: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
}

input CategoriesOnPostsPostIdCategoryIdCompoundUniqueInput {
  categoryId: String!
  postId: String!
}

enum CategoriesOnPostsScalarFieldEnum {
  categoryId
  createdAt
  postId
  updatedAt
}

input CategoriesOnPostsScalarWhereInput {
  AND: [CategoriesOnPostsScalarWhereInput!]
  NOT: [CategoriesOnPostsScalarWhereInput!]
  OR: [CategoriesOnPostsScalarWhereInput!]
  categoryId: StringFilter
  createdAt: DateTimeFilter
  postId: StringFilter
  updatedAt: DateTimeFilter
}

input CategoriesOnPostsScalarWhereWithAggregatesInput {
  AND: [CategoriesOnPostsScalarWhereWithAggregatesInput!]
  NOT: [CategoriesOnPostsScalarWhereWithAggregatesInput!]
  OR: [CategoriesOnPostsScalarWhereWithAggregatesInput!]
  categoryId: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  postId: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input CategoriesOnPostsUpdateInput {
  category: CategoryUpdateOneRequiredWithoutPostsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCategoriesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CategoriesOnPostsUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CategoriesOnPostsUpdateManyWithWhereWithoutCategoryInput {
  data: CategoriesOnPostsUpdateManyMutationInput!
  where: CategoriesOnPostsScalarWhereInput!
}

input CategoriesOnPostsUpdateManyWithWhereWithoutPostInput {
  data: CategoriesOnPostsUpdateManyMutationInput!
  where: CategoriesOnPostsScalarWhereInput!
}

input CategoriesOnPostsUpdateManyWithoutCategoryInput {
  connect: [CategoriesOnPostsWhereUniqueInput!]
  connectOrCreate: [CategoriesOnPostsCreateOrConnectWithoutCategoryInput!]
  create: [CategoriesOnPostsCreateWithoutCategoryInput!]
  createMany: CategoriesOnPostsCreateManyCategoryInputEnvelope
  delete: [CategoriesOnPostsWhereUniqueInput!]
  deleteMany: [CategoriesOnPostsScalarWhereInput!]
  disconnect: [CategoriesOnPostsWhereUniqueInput!]
  set: [CategoriesOnPostsWhereUniqueInput!]
  update: [CategoriesOnPostsUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [CategoriesOnPostsUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [CategoriesOnPostsUpsertWithWhereUniqueWithoutCategoryInput!]
}

input CategoriesOnPostsUpdateManyWithoutPostInput {
  connect: [CategoriesOnPostsWhereUniqueInput!]
  connectOrCreate: [CategoriesOnPostsCreateOrConnectWithoutPostInput!]
  create: [CategoriesOnPostsCreateWithoutPostInput!]
  createMany: CategoriesOnPostsCreateManyPostInputEnvelope
  delete: [CategoriesOnPostsWhereUniqueInput!]
  deleteMany: [CategoriesOnPostsScalarWhereInput!]
  disconnect: [CategoriesOnPostsWhereUniqueInput!]
  set: [CategoriesOnPostsWhereUniqueInput!]
  update: [CategoriesOnPostsUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [CategoriesOnPostsUpdateManyWithWhereWithoutPostInput!]
  upsert: [CategoriesOnPostsUpsertWithWhereUniqueWithoutPostInput!]
}

input CategoriesOnPostsUpdateWithWhereUniqueWithoutCategoryInput {
  data: CategoriesOnPostsUpdateWithoutCategoryInput!
  where: CategoriesOnPostsWhereUniqueInput!
}

input CategoriesOnPostsUpdateWithWhereUniqueWithoutPostInput {
  data: CategoriesOnPostsUpdateWithoutPostInput!
  where: CategoriesOnPostsWhereUniqueInput!
}

input CategoriesOnPostsUpdateWithoutCategoryInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCategoriesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CategoriesOnPostsUpdateWithoutPostInput {
  category: CategoryUpdateOneRequiredWithoutPostsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CategoriesOnPostsUpsertWithWhereUniqueWithoutCategoryInput {
  create: CategoriesOnPostsCreateWithoutCategoryInput!
  update: CategoriesOnPostsUpdateWithoutCategoryInput!
  where: CategoriesOnPostsWhereUniqueInput!
}

input CategoriesOnPostsUpsertWithWhereUniqueWithoutPostInput {
  create: CategoriesOnPostsCreateWithoutPostInput!
  update: CategoriesOnPostsUpdateWithoutPostInput!
  where: CategoriesOnPostsWhereUniqueInput!
}

input CategoriesOnPostsWhereInput {
  AND: [CategoriesOnPostsWhereInput!]
  NOT: [CategoriesOnPostsWhereInput!]
  OR: [CategoriesOnPostsWhereInput!]
  category: CategoryRelationFilter
  categoryId: StringFilter
  createdAt: DateTimeFilter
  post: PostRelationFilter
  postId: StringFilter
  updatedAt: DateTimeFilter
}

input CategoriesOnPostsWhereUniqueInput {
  postId_categoryId: CategoriesOnPostsPostIdCategoryIdCompoundUniqueInput
}

type Category {
  createdAt: DateTime!
  id: String!
  name: String!
  posts(cursor: CategoriesOnPostsWhereUniqueInput, distinct: [CategoriesOnPostsScalarFieldEnum!], orderBy: [CategoriesOnPostsOrderByInput!], skip: Int, take: Int, where: CategoriesOnPostsWhereInput): [CategoriesOnPosts!]!
  updatedAt: DateTime!
}

type CategoryCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input CategoryCreateInput {
  createdAt: DateTime
  id: String
  name: String!
  posts: CategoriesOnPostsCreateNestedManyWithoutCategoryInput
  updatedAt: DateTime
}

input CategoryCreateManyInput {
  createdAt: DateTime
  id: String
  name: String!
  updatedAt: DateTime
}

input CategoryCreateNestedOneWithoutPostsInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutPostsInput
  create: CategoryCreateWithoutPostsInput
}

input CategoryCreateOrConnectWithoutPostsInput {
  create: CategoryCreateWithoutPostsInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateWithoutPostsInput {
  createdAt: DateTime
  id: String
  name: String!
  updatedAt: DateTime
}

type CategoryGroupBy {
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  createdAt: DateTime!
  id: String!
  name: String!
  updatedAt: DateTime!
}

type CategoryMaxAggregate {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

type CategoryMinAggregate {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input CategoryOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input CategoryRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

enum CategoryScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input CategoryUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  posts: CategoriesOnPostsUpdateManyWithoutCategoryInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CategoryUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CategoryUpdateOneRequiredWithoutPostsInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutPostsInput
  create: CategoryCreateWithoutPostsInput
  update: CategoryUpdateWithoutPostsInput
  upsert: CategoryUpsertWithoutPostsInput
}

input CategoryUpdateWithoutPostsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CategoryUpsertWithoutPostsInput {
  create: CategoryCreateWithoutPostsInput!
  update: CategoryUpdateWithoutPostsInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  posts: CategoriesOnPostsListRelationFilter
  updatedAt: DateTimeFilter
}

input CategoryWhereUniqueInput {
  id: String
  name: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Mutation {
  createCategoriesOnPosts(data: CategoriesOnPostsCreateInput!): CategoriesOnPosts!
  createCategory(data: CategoryCreateInput!): Category!
  createManyCategoriesOnPosts(data: [CategoriesOnPostsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCategory(data: [CategoryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPost(data: [PostCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createPost(data: PostCreateInput!): Post!
  deleteCategoriesOnPosts(where: CategoriesOnPostsWhereUniqueInput!): CategoriesOnPosts
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategoriesOnPosts(where: CategoriesOnPostsWhereInput): AffectedRowsOutput!
  deleteManyCategory(where: CategoryWhereInput): AffectedRowsOutput!
  deleteManyPost(where: PostWhereInput): AffectedRowsOutput!
  deletePost(where: PostWhereUniqueInput!): Post
  updateCategoriesOnPosts(data: CategoriesOnPostsUpdateInput!, where: CategoriesOnPostsWhereUniqueInput!): CategoriesOnPosts
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategoriesOnPosts(data: CategoriesOnPostsUpdateManyMutationInput!, where: CategoriesOnPostsWhereInput): AffectedRowsOutput!
  updateManyCategory(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): AffectedRowsOutput!
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): AffectedRowsOutput!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  upsertCategoriesOnPosts(create: CategoriesOnPostsCreateInput!, update: CategoriesOnPostsUpdateInput!, where: CategoriesOnPostsWhereUniqueInput!): CategoriesOnPosts!
  upsertCategory(create: CategoryCreateInput!, update: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  upsertPost(create: PostCreateInput!, update: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Post {
  categories(cursor: CategoriesOnPostsWhereUniqueInput, distinct: [CategoriesOnPostsScalarFieldEnum!], orderBy: [CategoriesOnPostsOrderByInput!], skip: Int, take: Int, where: CategoriesOnPostsWhereInput): [CategoriesOnPosts!]!
  content: String!
  createdAt: DateTime!
  id: String!
  title: String!
  updatedAt: DateTime!
  userId: String!
}

type PostCountAggregate {
  _all: Int!
  content: Int!
  createdAt: Int!
  id: Int!
  title: Int!
  updatedAt: Int!
  userId: Int!
}

input PostCreateInput {
  categories: CategoriesOnPostsCreateNestedManyWithoutPostInput
  content: String!
  createdAt: DateTime
  id: String
  title: String!
  updatedAt: DateTime
  userId: String!
}

input PostCreateManyInput {
  content: String!
  createdAt: DateTime
  id: String
  title: String!
  updatedAt: DateTime
  userId: String!
}

input PostCreateNestedOneWithoutCategoriesInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutCategoriesInput
  create: PostCreateWithoutCategoriesInput
}

input PostCreateOrConnectWithoutCategoriesInput {
  create: PostCreateWithoutCategoriesInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutCategoriesInput {
  content: String!
  createdAt: DateTime
  id: String
  title: String!
  updatedAt: DateTime
  userId: String!
}

type PostGroupBy {
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  content: String!
  createdAt: DateTime!
  id: String!
  title: String!
  updatedAt: DateTime!
  userId: String!
}

type PostMaxAggregate {
  content: String
  createdAt: DateTime
  id: String
  title: String
  updatedAt: DateTime
  userId: String
}

type PostMinAggregate {
  content: String
  createdAt: DateTime
  id: String
  title: String
  updatedAt: DateTime
  userId: String
}

input PostOrderByInput {
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostRelationFilter {
  is: PostWhereInput
  isNot: PostWhereInput
}

enum PostScalarFieldEnum {
  content
  createdAt
  id
  title
  updatedAt
  userId
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput!]
  NOT: [PostScalarWhereWithAggregatesInput!]
  OR: [PostScalarWhereWithAggregatesInput!]
  content: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input PostUpdateInput {
  categories: CategoriesOnPostsUpdateManyWithoutPostInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
}

input PostUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
}

input PostUpdateOneRequiredWithoutCategoriesInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutCategoriesInput
  create: PostCreateWithoutCategoriesInput
  update: PostUpdateWithoutCategoriesInput
  upsert: PostUpsertWithoutCategoriesInput
}

input PostUpdateWithoutCategoriesInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
}

input PostUpsertWithoutCategoriesInput {
  create: PostCreateWithoutCategoriesInput!
  update: PostUpdateWithoutCategoriesInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  categories: CategoriesOnPostsListRelationFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input PostWhereUniqueInput {
  id: String
}

type Query {
  aggregateCategoriesOnPosts(cursor: CategoriesOnPostsWhereUniqueInput, orderBy: [CategoriesOnPostsOrderByInput!], skip: Int, take: Int, where: CategoriesOnPostsWhereInput): AggregateCategoriesOnPosts!
  aggregateCategory(cursor: CategoryWhereUniqueInput, orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): AggregateCategory!
  aggregatePost(cursor: PostWhereUniqueInput, orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): AggregatePost!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  findFirstCategoriesOnPosts(cursor: CategoriesOnPostsWhereUniqueInput, distinct: [CategoriesOnPostsScalarFieldEnum!], orderBy: [CategoriesOnPostsOrderByInput!], skip: Int, take: Int, where: CategoriesOnPostsWhereInput): CategoriesOnPosts
  findFirstCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstPost(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): Post
  findManyCategoriesOnPosts(cursor: CategoriesOnPostsWhereUniqueInput, distinct: [CategoriesOnPostsScalarFieldEnum!], orderBy: [CategoriesOnPostsOrderByInput!], skip: Int, take: Int, where: CategoriesOnPostsWhereInput): [CategoriesOnPosts!]!
  findUniqueCategoriesOnPosts(where: CategoriesOnPostsWhereUniqueInput!): CategoriesOnPosts
  groupByCategoriesOnPosts(by: [CategoriesOnPostsScalarFieldEnum!]!, having: CategoriesOnPostsScalarWhereWithAggregatesInput, orderBy: [CategoriesOnPostsOrderByInput!], skip: Int, take: Int, where: CategoriesOnPostsWhereInput): [CategoriesOnPostsGroupBy!]!
  groupByCategory(by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): [CategoryGroupBy!]!
  groupByPost(by: [PostScalarFieldEnum!]!, having: PostScalarWhereWithAggregatesInput, orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [PostGroupBy!]!
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}
